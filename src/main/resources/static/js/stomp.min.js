// Generated by CoffeeScript 1.7.1
/*
   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0

   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)
   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)
 */
(function() {
    // Shorthands for property checking and slicing arguments
    var hasProp = {}.hasOwnProperty;
    var slice = [].slice;

    // --- 1. Constants and Utility Functions ---
    var BYTE = {
        LF: "\n", // Line Feed
        NULL: "\x00" // Null character for frame separation
    };

    var now = function() {
        if (Date.now) {
            return Date.now();
        } else {
            return (new Date()).valueOf();
        }
    };

    // --- 2. Frame Class (Marshalling/Unmarshalling) ---

    // n -> Frame
    var Frame = (function() {
        // Constructor: n.prototype.constructor
        function Frame(command, headers, body) {
            this.command = command;
            this.headers = headers != null ? headers : {};
            this.body = body != null ? body : "";
        }

        // Frame.prototype.toString: Used for marshalling (sending)
        Frame.prototype.toString = function() {
            var lines = [this.command];
            var skipContentLength = this.headers["content-length"] === false;
            if (skipContentLength) {
                delete this.headers["content-length"];
            }

            // Add headers
            for (var headerKey in this.headers) {
                if (!hasProp.call(this.headers, headerKey)) continue;
                var headerValue = this.headers[headerKey];
                lines.push("" + headerKey + ":" + headerValue);
            }

            // Add content-length header if body exists and is not skipped
            if (this.body && !skipContentLength) {
                lines.push("content-length:" + Frame.sizeOfUTF8(this.body));
            }

            // Add the body, separated by an additional LF
            lines.push(BYTE.LF + this.body);

            return lines.join(BYTE.LF);
        };

        // Frame.sizeOfUTF8: Utility to calculate UTF-8 string length
        Frame.sizeOfUTF8 = function(str) {
            if (str) {
                return encodeURI(str).match(/%..|./g).length;
            } else {
                return 0;
            }
        };

        // Frame.unmarshallSingle: Parses a single raw frame string (e)
        var unmarshallSingle = function(data) {
            // Find the split between headers and body
            var separator = data.search(RegExp("" + BYTE.LF + BYTE.LF));
            var headerLines = data.substring(0, separator).split(BYTE.LF);
            var command = headerLines.shift(); // First line is the command
            var headers = {};

            // Parse headers
            var reversedLines = headerLines.reverse();
            for (var g = 0, m = reversedLines.length; g < m; g++) {
                var line = reversedLines[g];
                var colonIndex = line.indexOf(":");
                var trim = function(s) { return s.replace(/^\s+|\s+$/g, ""); };
                headers[trim(line.substring(0, colonIndex))] = trim(line.substring(colonIndex + 1));
            }

            // Extract body
            var body = "";
            var bodyStart = separator + 2; // +2 for the two LFs

            if (headers["content-length"]) {
                var len = parseInt(headers["content-length"]);
                body = ("" + data).substring(bodyStart, bodyStart + len);
            } else {
                // Read until null character if no content-length
                for (var i = bodyStart, end = data.length; i < end; i++) {
                    var char = data.charAt(i);
                    if (char === BYTE.NULL) {
                        break;
                    }
                    body += char;
                }
            }
            return new Frame(command, headers, body);
        };

        // Frame.unmarshall: Parses a string that may contain multiple frames (n.unmarshall)
        Frame.unmarshall = function(datas) {
            var parts = datas.split(RegExp("" + BYTE.NULL + BYTE.LF + "*"));
            var result = {
                frames: [],
                partial: ""
            };

            // Process all parts except the last one (which is the partial data)
            var completeParts = parts.slice(0, -1);
            result.frames = (function() {
                var frames = [];
                for (var i = 0, len = completeParts.length; i < len; i++) {
                    var part = completeParts[i];
                    frames.push(unmarshallSingle(part));
                }
                return frames;
            })();

            // The last part might be a partial frame or the end of a frame
            var lastPart = parts.slice(-1)[0];
            if (lastPart === BYTE.LF || lastPart.search(RegExp("" + BYTE.NULL + BYTE.LF + "*$")) !== -1) {
                // Complete frame detected
                result.frames.push(unmarshallSingle(lastPart));
            } else {
                // Incomplete frame, store as partial
                result.partial = lastPart;
            }
            return result;
        };

        // Frame.marshall: Creates a raw frame string (n.marshall)
        Frame.marshall = function(command, headers, body) {
            var frame = new Frame(command, headers, body);
            return frame.toString() + BYTE.NULL;
        };

        return Frame;
    })();

    // --- 3. Client Class (STOMP Connection) ---

    // e -> Client
    var Client = (function() {
        // Constructor: r.prototype.constructor
        function Client(ws) {
            this.ws = ws;
            this.ws.binaryType = "arraybuffer";
            this.counter = 0;
            this.connected = false;
            this.heartbeat = {
                outgoing: 10000, // Client will send heartbeats every 10s
                incoming: 10000 // Client expects server heartbeats every 10s
            };
            this.maxWebSocketFrameSize = 16 * 1024; // 16KB
            this.subscriptions = {};
            this.partialData = "";
        }

        // Client.prototype.debug: Debug logging
        Client.prototype.debug = function(message) {
            var console;
            return typeof window !== "undefined" && window !== null ? (console = window.console) != null ? console.log(message) : void 0 : void 0;
        };

        // Client.prototype._transmit: Sends a STOMP frame over the WebSocket
        Client.prototype._transmit = function(command, headers, body) {
            var rawFrame = Frame.marshall(command, headers, body);
            if (typeof this.debug === "function") {
                this.debug(">>> " + rawFrame);
            }

            // Handle splitting frame if it exceeds max size
            while (true) {
                if (rawFrame.length > this.maxWebSocketFrameSize) {
                    this.ws.send(rawFrame.substring(0, this.maxWebSocketFrameSize));
                    rawFrame = rawFrame.substring(this.maxWebSocketFrameSize);
                    if (typeof this.debug === "function") {
                        this.debug("remaining = " + rawFrame.length);
                    }
                } else {
                    return this.ws.send(rawFrame);
                }
            }
        };

        // Client.prototype._setupHeartbeat: Sets up pinger and ponger intervals
        Client.prototype._setupHeartbeat = function(serverHeaders) {
            var versions = Stomp.VERSIONS;
            // Check if server supports V1.1 or V1.2
            if (serverHeaders.version !== versions.V1_1 && serverHeaders.version !== versions.V1_2) {
                return;
            }

            var serverHeartbeat = (function() {
                var beats = serverHeaders["heart-beat"].split(",");
                var parsedBeats = [];
                for (var i = 0, len = beats.length; i < len; i++) {
                    parsedBeats.push(parseInt(beats[i]));
                }
                return parsedBeats;
            })();

            var serverSend = serverHeartbeat[0]; // Server's minimum time between sends
            var serverReceive = serverHeartbeat[1]; // Server's expected time between receives

            // Pinger (Client -> Server)
            if (!(this.heartbeat.outgoing === 0 || serverReceive === 0)) {
                var sendInterval = Math.max(this.heartbeat.outgoing, serverReceive);
                if (typeof this.debug === "function") {
                    this.debug("send PING every " + sendInterval + "ms");
                }
                this.pinger = Stomp.setInterval(sendInterval, (function(_this) {
                    return function() {
                        _this.ws.send(BYTE.LF); // Send PING (LF)
                        return typeof _this.debug === "function" ? _this.debug(">>> PING") : void 0;
                    };
                })(this));
            }

            // Ponger (Server -> Client check)
            if (!(this.heartbeat.incoming === 0 || serverSend === 0)) {
                var checkInterval = Math.max(this.heartbeat.incoming, serverSend);
                if (typeof this.debug === "function") {
                    this.debug("check PONG every " + checkInterval + "ms");
                }
                return this.ponger = Stomp.setInterval(checkInterval, (function(_this) {
                    return function() {
                        // serverActivity tracks the time of the last received server activity
                        var timeSinceLastActivity = now() - _this.serverActivity;
                        if (timeSinceLastActivity > checkInterval * 2) {
                            if (typeof _this.debug === "function") {
                                _this.debug("did not receive server activity for the last " + timeSinceLastActivity + "ms");
                            }
                            return _this.ws.close();
                        }
                    };
                })(this));
            }
        };

        // Client.prototype._parseConnect: Handles variable connect arguments
        Client.prototype._parseConnect = function() {
            var args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            var headers = {};
            var connectCallback, errorCallback;

            // Handle different argument signatures
            switch (args.length) {
                case 2:
                    headers = args[0], connectCallback = args[1];
                    break;
                case 3:
                    if (args[1] instanceof Function) {
                        headers = args[0], connectCallback = args[1], errorCallback = args[2];
                    } else {
                        headers.login = args[0], headers.passcode = args[1], connectCallback = args[2];
                    }
                    break;
                case 4:
                    headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3];
                    break;
                default:
                    // Supports up to 5 arguments, where the 5th is host
                    headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], headers.host = args[4];
            }
            return [headers, connectCallback, errorCallback];
        };

        // Client.prototype.connect: Connects to the STOMP server
        Client.prototype.connect = function() {
            var args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            var parsed = this._parseConnect.apply(this, args);
            var connectHeaders = parsed[0];
            this.connectCallback = parsed[1];
            var errorCallback = parsed[2];

            if (typeof this.debug === "function") {
                this.debug("Opening Web Socket...");
            }

            // --- WebSocket Event Handlers ---

            // OnMessage handler
            this.ws.onmessage = (function(_this) {
                return function(event) {
                    var data;
                    // Check for ArrayBuffer (binary data)
                    if (typeof ArrayBuffer !== "undefined" && event.data instanceof ArrayBuffer) {
                        var uint8Array = new Uint8Array(event.data);
                        if (typeof _this.debug === "function") {
                            _this.debug("--- got data length: " + uint8Array.length);
                        }
                        // Convert ArrayBuffer to string
                        data = (function() {
                            var chars = [];
                            for (var i = 0, len = uint8Array.length; i < len; i++) {
                                chars.push(String.fromCharCode(uint8Array[i]));
                            }
                            return chars;
                        })().join("");
                    } else {
                        data = event.data;
                    }

                    _this.serverActivity = now(); // Update last activity time

                    // Heartbeat PONG check (LF)
                    if (data === BYTE.LF) {
                        if (typeof _this.debug === "function") {
                            _this.debug("<<< PONG");
                        }
                        return;
                    }

                    if (typeof _this.debug === "function") {
                        _this.debug("<<< " + data);
                    }

                    // Unmarshall frames from incoming data
                    var unmarshalled = Frame.unmarshall(_this.partialData + data);
                    _this.partialData = unmarshalled.partial;
                    var frames = unmarshalled.frames;
                    var results = [];

                    for (var i = 0, len = frames.length; i < len; i++) {
                        var frame = frames[i];
                        switch (frame.command) {
                            case "CONNECTED":
                                if (typeof _this.debug === "function") {
                                    _this.debug("connected to server " + frame.headers.server);
                                }
                                _this.connected = true;
                                _this._setupHeartbeat(frame.headers);
                                results.push(typeof _this.connectCallback === "function" ? _this.connectCallback(frame) : void 0);
                                break;
                            case "MESSAGE":
                                var subscriptionId = frame.headers.subscription;
                                var handler = _this.subscriptions[subscriptionId] || _this.onreceive;

                                if (handler) {
                                    var client = _this;
                                    var messageId = frame.headers["message-id"];
                                    // Add ack and nack methods to the frame object
                                    frame.ack = function(headers) {
                                        if (headers == null) { headers = {}; }
                                        return client.ack(messageId, subscriptionId, headers);
                                    };
                                    frame.nack = function(headers) {
                                        if (headers == null) { headers = {}; }
                                        return client.nack(messageId, subscriptionId, headers);
                                    };
                                    results.push(handler(frame));
                                } else {
                                    results.push(typeof _this.debug === "function" ? _this.debug("Unhandled received MESSAGE: " + frame) : void 0);
                                }
                                break;
                            case "RECEIPT":
                                results.push(typeof _this.onreceipt === "function" ? _this.onreceipt(frame) : void 0);
                                break;
                            case "ERROR":
                                results.push(typeof errorCallback === "function" ? errorCallback(frame) : void 0);
                                break;
                            default:
                                results.push(typeof _this.debug === "function" ? _this.debug("Unhandled frame: " + frame) : void 0);
                        }
                    }
                    return results;
                };
            })(this);

            // OnClose handler
            this.ws.onclose = (function(_this) {
                return function() {
                    var errorMsg = "Whoops! Lost connection to " + _this.ws.url;
                    if (typeof _this.debug === "function") {
                        _this.debug(errorMsg);
                    }
                    _this._cleanUp();
                    return typeof errorCallback === "function" ? errorCallback(errorMsg) : void 0;
                };
            })(this);

            // OnOpen handler (sends CONNECT frame)
            return this.ws.onopen = (function(_this) {
                return function() {
                    if (typeof _this.debug === "function") {
                        _this.debug("Web Socket Opened...");
                    }
                    // Add protocol and heartbeat headers before connecting
                    connectHeaders["accept-version"] = Stomp.VERSIONS.supportedVersions();
                    connectHeaders["heart-beat"] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(",");
                    return _this._transmit("CONNECT", connectHeaders);
                };
            })(this);
        };

        // Client.prototype.disconnect: Disconnects from the server
        Client.prototype.disconnect = function(disconnectCallback, headers) {
            if (headers == null) { headers = {}; }
            this._transmit("DISCONNECT", headers);
            this.ws.onclose = null; // Prevent onclose from running errorCallback
            this.ws.close();
            this._cleanUp();
            return typeof disconnectCallback === "function" ? disconnectCallback() : void 0;
        };

        // Client.prototype._cleanUp: Clears connection state and intervals
        Client.prototype._cleanUp = function() {
            this.connected = false;
            if (this.pinger) {
                Stomp.clearInterval(this.pinger);
            }
            if (this.ponger) {
                return Stomp.clearInterval(this.ponger);
            }
        };

        // Client.prototype.send: Sends a message
        Client.prototype.send = function(destination, headers, body) {
            if (headers == null) { headers = {}; }
            if (body == null) { body = ""; }
            headers.destination = destination;
            return this._transmit("SEND", headers, body);
        };

        // Client.prototype.subscribe: Subscribes to a destination
        Client.prototype.subscribe = function(destination, callback, headers) {
            var client = this;
            if (headers == null) { headers = {}; }

            // Generate a unique ID if not provided
            if (!headers.id) {
                headers.id = "sub-" + this.counter++;
            }

            headers.destination = destination;
            this.subscriptions[headers.id] = callback;
            this._transmit("SUBSCRIBE", headers);

            return {
                id: headers.id,
                unsubscribe: function() {
                    return client.unsubscribe(headers.id);
                }
            };
        };

        // Client.prototype.unsubscribe: Unsubscribes by ID
        Client.prototype.unsubscribe = function(id) {
            delete this.subscriptions[id];
            return this._transmit("UNSUBSCRIBE", {
                id: id
            });
        };

        // Client.prototype.begin: Starts a transaction
        Client.prototype.begin = function(transactionId) {
            var client = this;
            var txId = transactionId || "tx-" + this.counter++;
            this._transmit("BEGIN", {
                transaction: txId
            });
            return {
                id: txId,
                commit: function() {
                    return client.commit(txId);
                },
                abort: function() {
                    return client.abort(txId);
                }
            };
        };

        // Client.prototype.commit: Commits a transaction
        Client.prototype.commit = function(transactionId) {
            return this._transmit("COMMIT", {
                transaction: transactionId
            });
        };

        // Client.prototype.abort: Aborts a transaction
        Client.prototype.abort = function(transactionId) {
            return this._transmit("ABORT", {
                transaction: transactionId
            });
        };

        // Client.prototype.ack: Acknowledges a message
        Client.prototype.ack = function(messageId, subscriptionId, headers) {
            if (headers == null) { headers = {}; }
            headers["message-id"] = messageId;
            headers.subscription = subscriptionId;
            return this._transmit("ACK", headers);
        };

        // Client.prototype.nack: Negative Acknowledgment
        Client.prototype.nack = function(messageId, subscriptionId, headers) {
            if (headers == null) { headers = {}; }
            headers["message-id"] = messageId;
            headers.subscription = subscriptionId;
            return this._transmit("NACK", headers);
        };

        return Client;
    })();

    // --- 4. Stomp API Object (Public Interface) ---

    // i -> Stomp
    var Stomp = {
        VERSIONS: {
            V1_0: "1.0",
            V1_1: "1.1",
            V1_2: "1.2",
            supportedVersions: function() {
                return "1.1,1.0"; // Note: V1.2 is supported but not included in this list in this version
            }
        },

        // Stomp.client: Creates a Client using a WebSocket URL
        client: function(url, protocols) {
            if (protocols == null) {
                protocols = ["v10.stomp", "v11.stomp"];
            }
            var WebSocketClass = Stomp.WebSocketClass || WebSocket;
            var ws = new WebSocketClass(url, protocols);
            return new Client(ws);
        },

        // Stomp.over: Creates a Client using an existing WebSocket object
        over: function(ws) {
            return new Client(ws);
        },

        Frame: Frame
    };

    // --- 5. Exporting and Environment Setup ---

    // Node.js/CommonJS export
    if (typeof exports !== "undefined" && exports !== null) {
        exports.Stomp = Stomp;
    }

    // Browser environment setup
    if (typeof window !== "undefined" && window !== null) {
        // Use window's native setInterval/clearInterval
        Stomp.setInterval = function(delay, callback) {
            return window.setInterval(callback, delay);
        };
        Stomp.clearInterval = function(id) {
            return window.clearInterval(id);
        };
        window.Stomp = Stomp;
    } else if (!exports) {
        // Non-browser, non-Node environment (e.g., Web Worker)
        self.Stomp = Stomp;
    }
}).call(this);